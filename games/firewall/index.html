<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Idle Auto Shooter - Vers√£o Final</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #151515; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }

        /* --- UI GERAL --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        .top-bar { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        .stat-box { font-size: 1.2rem; font-weight: bold; color: white; margin-bottom: 5px; }
        .gold-text { color: #ffd700; }
        .wave-text { color: #ff0055; font-size: 1.5rem; }

        /* ARTEFATOS (Icons no topo) */
        #artifacts-container { display: flex; gap: 10px; margin-top: 10px; }
        .artifact-icon { width: 40px; height: 40px; background: rgba(0,0,0,0.7); border: 2px solid #555; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 1.2rem; position: relative; color: #fff; }
        .artifact-lvl { position: absolute; bottom: -5px; right: -5px; background: #00c6ff; color: #000; font-size: 0.7rem; font-weight: bold; padding: 2px 4px; border-radius: 3px; }

        /* BARRAS */
        #bars-container { position: absolute; top: 0; left: 0; width: 100%; display: flex; flex-direction: column; z-index: 5; }
        .bar-bg { width: 100%; height: 8px; background: #333; }
        #xp-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #00c6ff, #0072ff); transition: width 0.2s; }
        #hp-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, 45px); width: 60px; height: 6px; background: #500; border: 1px solid #000; z-index: 4; }
        #hp-bar { width: 100%; height: 100%; background: #0f0; transition: width 0.1s; }
        #wave-timer { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.4); font-size: 0.9rem; }

        /* --- LOJA --- */
        #shop-container { pointer-events: auto; margin-bottom: 20px; display: flex; justify-content: center; gap: 10px; }
        .shop-btn { background: rgba(0, 0, 0, 0.9); border: 1px solid #444; border-radius: 6px; padding: 8px 12px; color: white; cursor: pointer; text-align: center; min-width: 90px; transition: 0.2s; display: flex; flex-direction: column; align-items: center; }
        .shop-btn:hover { border-color: #fff; transform: translateY(-3px); }
        .shop-btn.disabled { opacity: 0.4; cursor: not-allowed; border-color: #333; transform: none; }
        .btn-icon { font-size: 1.2rem; }
        .btn-header { display: flex; gap: 5px; align-items: center; margin-bottom: 2px; }
        .btn-desc { font-size: 0.65rem; color: #aaa; margin-bottom: 4px; max-width: 80px; }
        .btn-cost { font-size: 0.8rem; color: #ffd700; font-weight: bold; }
        .btn-lvl { font-size: 0.6rem; color: #00ffff; margin-bottom: 2px;}

        /* --- SETTINGS & LEADERBOARD --- */
        #settings-btn { position: absolute; top: 20px; right: 20px; z-index: 90; font-size: 1.5rem; background: none; border: none; cursor: pointer; transition: transform 0.2s; pointer-events: auto; }
        #settings-btn:hover { transform: rotate(90deg) scale(1.1); }
        #settings-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; display: none; flex-direction: column; align-items: center; justify-content: center; color: #fff; pointer-events: auto; }
        #settings-modal.visible { display: flex; }
        .setting-row { display: flex; align-items: center; gap: 20px; margin-bottom: 20px; font-size: 1.2rem; }
        input[type=range] { width: 200px; cursor: pointer; }
        .danger-btn { margin-top: 30px; padding: 10px 20px; background: #500; color: #fff; border: 1px solid #f00; cursor: pointer; font-weight: bold; }
        .danger-btn:hover { background: #f00; }
        .leaderboard-box { margin-top: 20px; background: #222; padding: 20px; border-radius: 10px; border: 1px solid #444; width: 300px; max-height: 200px; overflow-y: auto; }
        .lb-row { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #333; font-family: monospace; font-size: 0.9rem; }
        .lb-header { color: #ffd700; font-weight: bold; margin-bottom: 10px; text-align: center; }

        /* --- CARDS --- */
        .overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; }
        .overlay-screen.visible { display: flex; animation: fadeIn 0.3s; }
        .card-container { display: flex; gap: 20px; margin-top: 20px; flex-wrap: wrap; justify-content: center;}
        .card { width: 160px; height: 240px; background: #222; border: 2px solid #444; border-radius: 10px; padding: 15px; display: flex; flex-direction: column; align-items: center; text-align: center; cursor: pointer; transition: 0.2s; box-shadow: 0 0 15px rgba(0,0,0,0.5); position: relative; }
        .card:hover { transform: scale(1.05); background: #2a2a2a; }
        .card-icon { font-size: 3rem; margin-bottom: 10px; }
        .card-title { font-weight: bold; color: #fff; margin-bottom: 5px; font-size: 0.9rem;}
        .card-desc { font-size: 0.8rem; color: #bbb; line-height: 1.4; margin-bottom: auto;}
        .card-lvl { margin-top: 10px; color: #fff; font-size: 0.8rem; font-weight: bold; background: #000; padding: 5px; border-radius: 5px; width: 100%;}
        
        /* Card Types */
        .card.new-power { border-color: #00c6ff; box-shadow: 0 0 15px rgba(0, 198, 255, 0.2); }
        .card.upgrade-power { border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.2); }
        .card-type { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 10px; font-weight: bold; }
        .new-power .card-type { color: #00c6ff; }
        .upgrade-power .card-type { color: #ffd700; }

        /* Alerts */
        .enemy-alert-box { border: 4px solid #ff0055; padding: 40px; background: #111; text-align: center; max-width: 400px; border-radius: 20px; box-shadow: 0 0 50px rgba(255, 0, 85, 0.3); }
        .enemy-shape { margin: 20px auto; width: 60px; height: 60px; }
        .enemy-name { font-size: 2rem; color: #ff0055; font-weight: bold; text-transform: uppercase; }
        .enemy-desc { color: #fff; font-style: italic; margin: 15px 0 30px 0; font-size: 1.1rem; }
        .continue-btn { padding: 10px 30px; background: #ff0055; border: none; color: white; font-weight: bold; font-size: 1.2rem; cursor: pointer; border-radius: 5px; }
        .continue-btn:hover { background: #fff; color: #ff0055; }

        /* Utils */
        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 50; }
        #notification { position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); font-size: 2.5rem; font-weight: bold; color: #fff; opacity: 0; transition: opacity 0.5s; text-shadow: 0 0 10px #000; z-index: 80; pointer-events: none; text-align: center; width: 100%; }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>

    <button id="settings-btn" onclick="toggleSettings()">‚öôÔ∏è</button>

    <div id="settings-modal">
        <h2 style="color: #fff; text-transform: uppercase; letter-spacing: 3px;">Configura√ß√µes</h2>
        
        <div class="setting-row">
            <span>Volume Geral</span>
            <input type="range" min="0" max="1" step="0.1" value="0.5" onchange="audioSys.setVolume('master', this.value)">
        </div>
        <div class="setting-row">
            <span>M√∫sica</span>
            <input type="range" min="0" max="1" step="0.1" value="0.5" onchange="audioSys.setVolume('music', this.value)">
        </div>
        <div class="setting-row">
            <span>Efeitos (SFX)</span>
            <input type="range" min="0" max="1" step="0.1" value="0.5" onchange="audioSys.setVolume('sfx', this.value)">
        </div>

        <button class="continue-btn" onclick="toggleSettings()" style="margin-top: 20px;">Voltar ao Jogo</button>
        <button class="danger-btn" onclick="clearData()">APAGAR RANKING (Frangote?)</button>
    </div>

    <div id="damage-overlay"></div>

    <div id="levelup-screen" class="overlay-screen">
        <h1 style="color: #00c6ff; text-transform: uppercase; font-size: 3rem; margin: 0;">Level Up!</h1>
        <p style="color: #fff;">Escolha uma melhoria</p>
        <div class="card-container" id="cards-wrapper"></div>
    </div>

    <div id="new-enemy-screen" class="overlay-screen">
        <div class="enemy-alert-box">
            <div style="color: #666; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 2px;">Nova Amea√ßa Detectada</div>
            <div class="enemy-shape" id="new-enemy-visual"></div>
            <div class="enemy-name" id="new-enemy-name">NOME</div>
            <div class="enemy-desc" id="new-enemy-desc">Descri√ß√£o aqui.</div>
            <button class="continue-btn" onclick="resumeGame()">VEM PRO PAU</button>
        </div>
    </div>

    <div id="game-over-screen" class="overlay-screen">
        </div>

    <div id="bars-container"><div class="bar-bg"><div id="xp-bar"></div></div></div>
    <div id="hp-container"><div id="hp-bar"></div></div>

    <div id="ui-layer">
        <div class="top-bar">
            <div>
                <div class="stat-box wave-text">ONDA <span id="wave">1</span></div>
                <div class="stat-box">Abates: <span id="score">0</span></div>
                <div id="artifacts-container"></div>
            </div>
            <div class="stat-box gold-text">Ouro: <span id="gold">0</span></div>
        </div>
        <div id="wave-timer">Pr√≥xima onda: <span id="timer">30</span>s</div>
        <div id="shop-container"></div>
    </div>

    <div id="notification"></div>
    <canvas id="gameCanvas"></canvas>

<script>
    // --- 1. AUDIO SYSTEM ---
    class AudioSystem {
        constructor() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            
            // Filtro Lowpass (Efeito Abafado)
            this.filter = this.ctx.createBiquadFilter();
            this.filter.type = 'lowpass';
            this.filter.frequency.value = 22000;
            this.filter.connect(this.masterGain);

            this.volumes = { master: 0.5, music: 0.5, sfx: 0.5 };
            this.bgm = null;
            
            // Simula√ß√£o de caminhos (Voc√™ precisar√° dos arquivos reais)
            this.files = {
                shoot: 'sfx/shoot.mp3', hit: 'sfx/playerhit.mp3', explosion: 'sfx/explosion.mp3', coin: 'sfx/coin.mp3',
                levelup: 'sfx/levelup.mp3', gameover: 'sfx/gameover.mp3', bgm: 'music/back_music.mp3', newenemy: 'sfx/glitchnewenemy.mp3'
            };

            // Inicializa BGM
            this.bgm = new Audio(this.files.bgm);
            this.bgm.loop = true;
            this.bgm.volume = this.volumes.music * this.volumes.master;
            this.masterGain.gain.value = this.volumes.master;
        }

        playSound(key) {
            // Nota: Se n√£o tiver arquivo, vai dar erro no console (Silent Fail)
            try {
                const audio = new Audio(this.files[key]);
                audio.volume = this.volumes.sfx * this.volumes.master;
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => { /* Autoplay block ignorado */ });
                }
            } catch (e) { console.log("Audio file missing: " + key); }
        }

        playMusic() {
            try {
                this.bgm.volume = this.volumes.music * this.volumes.master;
                const playPromise = this.bgm.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => { console.log("Clique no jogo para iniciar a m√∫sica."); });
                }
            } catch (e) {}
        }

        setMuffled(isMuffled) {
            const freq = isMuffled ? 600 : 22000;
            this.filter.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.1);
        }

        setVolume(type, val) {
            this.volumes[type] = parseFloat(val);
            if (type === 'master') {
                this.masterGain.gain.value = this.volumes.master;
                this.bgm.volume = this.volumes.music * this.volumes.master;
            }
            if (type === 'music') {
                this.bgm.volume = this.volumes.music * this.volumes.master;
            }
        }
    }
    const audioSys = new AudioSystem();

    // --- 2. CONFIGURA√á√ïES GERAIS ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Refer√™ncias de UI Unificadas
    const ui = {
        score: document.getElementById('score'),
        gold: document.getElementById('gold'),
        wave: document.getElementById('wave'),
        xpBar: document.getElementById('xp-bar'),
        hpBar: document.getElementById('hp-bar'),
        timer: document.getElementById('timer'),
        notif: document.getElementById('notification'),
        dmgOverlay: document.getElementById('damage-overlay'),
        shopContainer: document.getElementById('shop-container'),
        artifactsContainer: document.getElementById('artifacts-container'),
        settingsModal: document.getElementById('settings-modal'),
        cardsWrapper: document.getElementById('cards-wrapper'),
        screens: {
            levelup: document.getElementById('levelup-screen'),
            newEnemy: document.getElementById('new-enemy-screen'),
            gameOver: document.getElementById('game-over-screen')
        },
        newEnemy: {
            visual: document.getElementById('new-enemy-visual'),
            name: document.getElementById('new-enemy-name'),
            desc: document.getElementById('new-enemy-desc')
        }
    };

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

// --- DADOS ATUALIZADOS ---
    const UPGRADES_DEF = {
        damage: { name: "Dano", icon: "‚öîÔ∏è", desc: "+ Dano Base", baseCost: 20, val: 10, inc: 4 }, // Pre√ßo reduzido
        speed:  { name: "Velocidade", icon: "‚ö°", desc: "- Delay Tiro", baseCost: 30, val: 60, dec: 3, min: 4 }, // Bem mais barato
        range:  { name: "Alcance", icon: "üéØ", desc: "+ Raio Radar", baseCost: 25, val: 200, inc: 20 },
        hp:     { name: "Resist√™ncia", icon: "‚ù§Ô∏è", desc: "+ Vida M√°x", baseCost: 40, val: 100, inc: 20 }
    };

    const ARTIFACTS_DEF = {
        // --- Cl√°ssicos ---
        poison: { name: "Nuvem T√≥xica", icon: "‚ò†Ô∏è", color: "#0f0", maxLvl: 5, desc: "Dano em √°rea constante.", upgDesc: "Aumenta raio e dano.", baseDmg: 0.2, rangePct: 0.35 },
        freeze: { name: "Balas Cryo", icon: "‚ùÑÔ∏è", color: "#00ffff", maxLvl: 5, desc: "Congela inimigos.", upgDesc: "+ Tempo congelado.", duration: 30 },
        shield: { name: "Escudo Eletro", icon: "üõ°Ô∏è", color: "#0072ff", maxLvl: 5, desc: "Bloqueia 1 golpe.", upgDesc: "- Tempo de recarga.", cooldown: 1800 },
        midas: { name: "Toque de Midas", icon: "üí∞", color: "#ffd700", maxLvl: 5, desc: "Inimigos dropam ouro ao tocar.", upgDesc: "+ Chance de drop.", chance: 1.0 },
        vampire: { name: "Vampirismo", icon: "ü©∏", color: "#ff0000", maxLvl: 5, desc: "Cura ao matar.", upgDesc: "+ Cura por abate.", heal: 2 },
        explosive: { name: "Muni√ß√£o Explosiva", icon: "üí•", color: "#ffaa00", maxLvl: 5, desc: "Dano em √°rea no impacto.", upgDesc: "+ √Årea e dano.", radius: 60, dmgPct: 0.5 },
        knockback: { name: "Empurr√£o", icon: "ü•ä", color: "#ffffff", maxLvl: 5, desc: "Empurra inimigos.", upgDesc: "+ For√ßa.", force: 10 },
        
        // --- NOVOS ---
        piercing: { name: "Perfurante", icon: "üèπ", color: "#888", maxLvl: 5, desc: "Atravessa inimigos.", upgDesc: "+1 Inimigo perfurado.", count: 1 },
        orbital: { name: "Orbital", icon: "ü™ê", color: "#ff00ff", maxLvl: 5, desc: "Esferas giram e d√£o dano.", upgDesc: "+1 Esfera e velocidade.", count: 1, dmg: 5 },
        zapp: { name: "Super Choque", icon: "‚ö°", color: "#ffeb3b", maxLvl: 5, desc: "Raio aleat√≥rio insta-hit.", upgDesc: "- Cooldown do raio.", cooldown: 180 }, // 3s inicial
        sniper: { name: "Bal√≠stica", icon: "üî≠", color: "#4caf50", maxLvl: 5, desc: "Mais dano longe do canh√£o.", upgDesc: "+ Multiplicador de dist√¢ncia.", mult: 0.005 }, // 0.5% por pixel
        echo: { name: "Eco", icon: "üîä", color: "#00bcd4", maxLvl: 5, desc: "Tiro ricocheteia ao acertar.", upgDesc: "+ Dano do ricochete.", dmgPct: 0.4 }
    };

    const CLASSES_DEF = {
        sniper: { name: "Sniper", icon: "üî≠", color: "#4caf50", desc: "+30% Range/Dano, -20% Speed/HP", stats: { range: 1.3, damage: 1.3, speed: 1.2, maxHp: 0.8 } }, // Speed maior = mais lento (delay)
        machine: { name: "Metralhadora", icon: "üî´", color: "#ff9800", desc: "+100% Speed, -60% Dano", stats: { speed: 0.5, damage: 0.4 } }, // Speed menor = mais r√°pido
        shotgun: { name: "Escopeta", icon: "üß®", color: "#795548", desc: "+40% Dano, -30% Range", stats: { damage: 1.4, range: 0.7 } },
        tank: { name: "Tanque", icon: "üõ°Ô∏è", color: "#607d8b", desc: "+50% HP, +30% Dano, -50% Speed", stats: { maxHp: 1.5, damage: 1.3, speed: 1.5 } }
    };

    const ENEMIES_DEF = {
        square: { name: "Cubo", color: "#ff4444", shape: "square", desc: "Carne de canh√£o.", minWave: 1 },
        triangle: { name: "Velocista", color: "#ffff00", shape: "triangle", desc: "R√°pido e fr√°gil.", minWave: 2 },
        circle: { name: "Tanque", color: "#aa00ff", shape: "circle", desc: "Resistente.", minWave: 4 }, // HP ajustado na classe Enemy
        rhombus: { name: "Ladino", color: "#00ffaa", shape: "rhombus", desc: "D√° investidas r√°pidas.", minWave: 5 },
        hexagon: { name: "Cl√©rigo", color: "#00ff00", shape: "hexagon", desc: "Cura os aliados.", minWave: 6 }
    };

    // --- GAME STATE ---
    let game = {
        state: 'PLAYING', score: 0, gold: 0, level: 1, xp: 0, xpNext: 100,
        wave: 1, waveTimer: 30, spawnRate: 160, lastTime: 0,
        upgrades: {}, artifacts: {}, spawnPool: ['square'], isRunning: true
    };
    let player;
    let entities = { bullets: [], enemies: [], particles: [], drops: [] };
    let spawnTimer = 0;
    let animationId; // Para controle do loop

    // --- FUN√á√ïES GLOBAIS ---

    function init() {
        if (animationId) cancelAnimationFrame(animationId); // Evita loop duplicado

        // Reset
        game = {
            state: 'PLAYING', score: 0, gold: 0, level: 1, xp: 0, xpNext: 100,
            wave: 1, waveTimer: 30, spawnRate: 160, lastTime: 0,
            upgrades: JSON.parse(JSON.stringify(UPGRADES_DEF)), 
            artifacts: {}, spawnPool: ['square'], isRunning: true
        };
        // Inicializa upgrades
        for(let k in game.upgrades) {
            game.upgrades[k].level = 1; game.upgrades[k].currentVal = game.upgrades[k].val; game.upgrades[k].cost = game.upgrades[k].baseCost;
        }

        player = new Player();
        entities = { bullets: [], enemies: [], particles: [], drops: [] };
        spawnTimer = 0;
        
        // UI Reset
        Object.values(ui.screens).forEach(s => s.classList.remove('visible'));
        ui.score.innerText = 0; ui.gold.innerText = 0; ui.wave.innerText = 1;
        ui.xpBar.style.width = '0%'; ui.hpBar.style.width = '100%'; ui.hpBar.style.backgroundColor='#0f0';
        
        updateShopUI();
        updateArtifactsUI();

        // Tenta tocar m√∫sica
        document.body.onclick = () => { audioSys.playMusic(); document.body.onclick = null; }

        loop(0);
    }

    function showNotification(txt, color='#fff') {
        ui.notif.innerText = txt;
        ui.notif.style.color = color;
        ui.notif.style.opacity = 1;
        setTimeout(() => ui.notif.style.opacity = 0, 1500);
    }

    // --- PERSIST√äNCIA & RANKING ---
    function saveScoreLocal() {
        const totalScore = (game.wave * 10) + (game.level * 5) + game.score;
        const record = { date: new Date().toLocaleDateString(), wave: game.wave, score: totalScore };
        let rank = JSON.parse(localStorage.getItem('autoShooter_rank') || "[]");
        rank.push(record);
        rank.sort((a, b) => b.score - a.score);
        rank = rank.slice(0, 5);
        localStorage.setItem('autoShooter_rank', JSON.stringify(rank));
        return rank;
    }

    function clearData() {
        if(confirm("Tem certeza, frangote? Isso apagar√° todo seu hist√≥rico.")) {
            localStorage.removeItem('autoShooter_rank');
            alert("Ranking apagado.");
            toggleSettings();
        }
    }

    function getLeaderboardHTML(rankData) {
        if (!rankData || rankData.length === 0) return '<div style="color:#666; margin-top:10px;">Sem registros...</div>';
        let html = '<div class="leaderboard-box"><div class="lb-header">TOP 5 JOGADORES</div>';
        rankData.forEach((r, i) => {
            html += `<div class="lb-row"><span>#${i+1} ${r.date}</span><span>W:${r.wave} PTS:${r.score}</span></div>`;
        });
        html += '</div>';
        return html;
    }

    function toggleSettings() {
        const modal = ui.settingsModal;
        modal.classList.toggle('visible');
        if (modal.classList.contains('visible')) {
            if (game.state === 'PLAYING') { game.state = 'PAUSED_SETTINGS'; audioSys.setMuffled(true); }
        } else {
            if (game.state === 'PAUSED_SETTINGS') { game.state = 'PLAYING'; audioSys.setMuffled(false); }
        }
    }

    // --- SHOP & UPGRADES ---
    function updateShopUI() {
        ui.shopContainer.innerHTML = '';
        for (let key in game.upgrades) {
            const upg = game.upgrades[key];
            const btn = document.createElement('div');
            btn.className = `shop-btn ${game.gold >= upg.cost ? '' : 'disabled'}`;
            btn.onclick = () => buyBaseUpgrade(key);
            btn.innerHTML = `
                <div class="btn-header"><span class="btn-icon">${upg.icon}</span> <span class="btn-lvl">Lv.${upg.level}</span></div>
                <div class="btn-desc">${upg.desc}</div>
                <div class="btn-cost">$${upg.cost}</div>
            `;
            ui.shopContainer.appendChild(btn);
        }
    }

    function buyBaseUpgrade(key) {
        if (game.state !== 'PLAYING') return;
        const upg = game.upgrades[key];
        if (game.gold >= upg.cost) {
            game.gold -= upg.cost; ui.gold.innerText = game.gold;
            upg.level++; upg.cost = Math.floor(upg.cost * 1.3);
            
            if (key === 'damage') { upg.currentVal += upg.inc; player.damage = upg.currentVal; }
            else if (key === 'speed') { upg.currentVal = Math.max(upg.min, upg.currentVal - upg.dec); player.fireRate = upg.currentVal; }
            else if (key === 'range') { upg.currentVal += upg.inc; player.range = upg.currentVal; }
            else if (key === 'hp') { 
                upg.currentVal += upg.inc; player.maxHp = upg.currentVal; 
                player.hp += upg.inc; player.updateHpUI();
            }
            updateShopUI(); showNotification(`${upg.name} UP!`);
        }
    }

    // --- CARDS & LEVEL UP ---
    // --- LEVEL UP LOGIC ---
    function checkLevelUp() {
        if (game.xp >= game.xpNext) {
            game.xp = 0; game.level++; game.xpNext = Math.floor(game.xpNext * 1.3);
            ui.xpBar.style.width = '0%';
            game.state = 'PAUSED_LVL'; audioSys.setMuffled(true); audioSys.playSound('levelup');
            
            // ESPECIAL LEVEL 5: ESCOLHA DE CLASSE
            if (game.level === 5) {
                generateClassCards();
            } else {
                generateCards();
            }
            
            ui.screens.levelup.classList.add('visible');
            saveScoreLocal();
        } else { ui.xpBar.style.width = (game.xp / game.xpNext * 100) + '%'; }
    }

    function generateClassCards() {
        ui.cardsWrapper.innerHTML = '';
        const title = document.querySelector('#levelup-screen h1');
        title.innerText = "ESPECIALIZA√á√ÉO";
        title.style.color = "#ff00ff"; // Roxo para destacar
        
        for (let key in CLASSES_DEF) {
            const def = CLASSES_DEF[key];
            const card = document.createElement('div');
            card.className = 'card new-power';
            card.style.borderColor = def.color;
            card.onclick = () => selectClass(key);
            
            card.innerHTML = `
                <div class="card-type" style="color:${def.color}">CLASSE</div>
                <div class="card-icon" style="color:${def.color}">${def.icon}</div>
                <div class="card-title">${def.name}</div>
                <div class="card-desc" style="font-size:0.9rem">${def.desc}</div>
                <div class="card-lvl">Escolha √önica</div>
            `;
            ui.cardsWrapper.appendChild(card);
        }
    }

    function selectClass(key) {
        const def = CLASSES_DEF[key];
        const s = def.stats;
        
        // Aplica modificadores permanentes
        if(s.damage) { player.damage *= s.damage; game.upgrades.damage.currentVal = player.damage; }
        if(s.range) { player.range *= s.range; game.upgrades.range.currentVal = player.range; }
        if(s.maxHp) { player.maxHp *= s.maxHp; player.hp = player.maxHp; game.upgrades.hp.currentVal = player.maxHp; player.updateHpUI(); }
        if(s.speed) { player.fireRate *= s.speed; game.upgrades.speed.currentVal = player.fireRate; }

        showNotification(`CLASSE: ${def.name.toUpperCase()}!`, def.color);
        
        // Reseta titulo do modal
        document.querySelector('#levelup-screen h1').innerText = "LEVEL UP!";
        document.querySelector('#levelup-screen h1').style.color = "#00c6ff";
        
        closeLevelUp();
    }

    function generateCards() {
        ui.cardsWrapper.innerHTML = '';
        const allKeys = Object.keys(ARTIFACTS_DEF);
        const ownedKeys = Object.keys(game.artifacts);
        
        let pool = [];
        allKeys.forEach(key => {
            if (game.artifacts[key] >= ARTIFACTS_DEF[key].maxLvl) return;
            pool.push(key);
            if (ownedKeys.includes(key)) pool.push(key); // Peso duplo para o que j√° tem
        });

        if (pool.length === 0) {
             ui.cardsWrapper.innerHTML = `<div class="card upgrade-power" onclick="player.hp=player.maxHp; player.updateHpUI(); closeLevelUp()"><div class="card-icon">‚ù§Ô∏è</div><div class="card-title">Cura Total</div><div class="card-desc">Maxed Out!</div></div>`;
             return;
        }

        let choices = [];
        while(choices.length < 3 && pool.length > 0) {
            const rand = pool[Math.floor(Math.random() * pool.length)];
            pool = pool.filter(k => k !== rand);
            choices.push(rand);
        }

        choices.forEach(key => {
            const def = ARTIFACTS_DEF[key];
            const currentLvl = game.artifacts[key] || 0;
            const isNew = currentLvl === 0;

            const card = document.createElement('div');
            card.className = `card ${isNew ? 'new-power' : 'upgrade-power'}`;
            card.onclick = () => selectArtifact(key);
            
            // Texto Personalizado
            const desc = isNew ? def.desc : (def.upgDesc || "Melhora o efeito atual.");

            card.innerHTML = `
                <div class="card-type">${isNew ? "NOVO PODER" : "MELHORIA"}</div>
                <div class="card-icon" style="color:${def.color}">${def.icon}</div>
                <div class="card-title">${def.name}</div>
                <div class="card-desc">${desc}</div>
                <div class="card-lvl">${isNew ? 'Desbloquear' : 'Lvl ' + currentLvl + ' ‚û§ ' + (currentLvl+1)}</div>
            `;
            ui.cardsWrapper.appendChild(card);
        });
    }

    function selectArtifact(key) {
        if (!game.artifacts[key]) game.artifacts[key] = 0;
        game.artifacts[key]++;
        if (key === 'shield') player.shieldTimer = 0; 
        updateArtifactsUI(); closeLevelUp();
    }

    function updateArtifactsUI() {
        ui.artifactsContainer.innerHTML = '';
        for (let key in game.artifacts) {
            const def = ARTIFACTS_DEF[key];
            const lvl = game.artifacts[key];
            const div = document.createElement('div');
            div.className = 'artifact-icon';
            div.style.borderColor = def.color;
            div.innerHTML = `${def.icon} <span class="artifact-lvl">${lvl}</span>`;
            ui.artifactsContainer.appendChild(div);
        }
    }

    function closeLevelUp() {
        ui.screens.levelup.classList.remove('visible');
        game.state = 'PLAYING'; audioSys.setMuffled(false);
    }

    // --- GAMEPLAY HELPERS ---
    function nextWave() {
        game.wave++; game.waveTimer = 30; 
        // APOCALYPSE CURVE: Reduz spawnRate drasticamente
        // Come√ßa em 160. Onda 10 deve ser insana (ex: 20 frames = 3 inimigos por segundo)
        game.spawnRate = Math.max(15, Math.floor(160 * Math.pow(0.85, game.wave))); 
        
        ui.wave.innerText = game.wave;
        let newEnemyKey = null;
        for (let key in ENEMIES_DEF) {
            if (ENEMIES_DEF[key].minWave === game.wave && !game.spawnPool.includes(key)) {
                newEnemyKey = key; break;
            }
        }
        if (newEnemyKey) {
            game.state = 'PAUSED_ENEMY'; audioSys.setMuffled(true);
            audioSys.playSound('newenemy')
            const def = ENEMIES_DEF[newEnemyKey];
            ui.newEnemy.name.innerText = def.name; ui.newEnemy.name.style.color = def.color;
            ui.newEnemy.desc.innerText = def.desc;
            ui.newEnemy.visual.style.backgroundColor = def.color;
            ui.newEnemy.visual.style.borderRadius = def.shape === 'circle' ? '50%' : '0';
            ui.newEnemy.visual.style.clipPath = def.shape === 'triangle' ? 'polygon(50% 0%, 0% 100%, 100% 100%)' : 'none';
            game.spawnPool.push(newEnemyKey);
            ui.screens.newEnemy.classList.add('visible');
        } else {
            showNotification(`ONDA ${game.wave}`, '#ff0055');
        }
        saveScoreLocal();
    }

    window.resumeGame = function() {
        ui.screens.newEnemy.classList.remove('visible');
        game.state = 'PLAYING'; audioSys.setMuffled(false);
    }
    
    window.restartGame = init;

    function endGame() {
        game.isRunning = false; game.state = 'GAMEOVER'; audioSys.setMuffled(true); audioSys.playSound('gameover');
        const rank = saveScoreLocal();
        const rankHTML = getLeaderboardHTML(rank);
        const goScreen = ui.screens.gameOver;
        goScreen.innerHTML = `
            <h1 style="color: #ff0055; font-size: 4rem; margin-bottom: 10px;">GAME OVER</h1>
            <p style="color: #fff; font-size: 1.2rem;">Onda alcan√ßada: <span style="color:#fff; font-weight:bold">${game.wave}</span></p>
            ${rankHTML}
            <button class="continue-btn" onclick="restartGame()" style="margin-top:20px">Tentar Novamente</button>
        `;
        goScreen.classList.add('visible');
    }

    // --- CLASSES ---
    class Player {
        constructor() {
            this.x = canvas.width/2; this.y = canvas.height/2;
            this.size = 25; this.color = '#00ffcc';
            this.maxHp = game.upgrades.hp.currentVal; this.hp = this.maxHp;
            this.range = game.upgrades.range.currentVal;
            this.damage = game.upgrades.damage.currentVal;
            this.fireRate = game.upgrades.speed.currentVal;
            this.angle = 0; this.cooldown = 0; this.regenTimer = 0;
            this.shieldActive = false; this.shieldTimer = 0; this.poisonTimer = 0;
        }

        update() {
            this.x = canvas.width/2; this.y = canvas.height/2;

            // Regen
            if (Date.now() - this.regenTimer > 3000 && this.hp < this.maxHp) {
                this.hp += 0.05; this.updateHpUI();
            }

            // Power: SHIELD
            if (game.artifacts.shield) {
                const def = ARTIFACTS_DEF.shield;
                const cd = Math.max(600, def.cooldown - (game.artifacts.shield * 200));
                if (!this.shieldActive) {
                    this.shieldTimer++;
                    if (this.shieldTimer >= cd) { this.shieldActive = true; showNotification("ESCUDO PRONTO", "#0072ff"); }
                }
            }

            // Power: ZAPP (Raio)
            if (game.artifacts.zapp) {
                if (!this.zappTimer) this.zappTimer = 0;
                this.zappTimer++;
                const cd = ARTIFACTS_DEF.zapp.cooldown - (game.artifacts.zapp * 20);
                if (this.zappTimer >= cd && entities.enemies.length > 0) {
                    this.zappTimer = 0;
                    // Pega inimigo aleat√≥rio no range
                    const targets = entities.enemies.filter(e => Math.hypot(e.x-this.x, e.y-this.y) <= this.range);
                    if (targets.length > 0) {
                        const target = targets[Math.floor(Math.random() * targets.length)];
                        target.takeDamage(50 + (game.artifacts.zapp * 20)); // Dano alto
                        // Desenha raio visual (simples linha amarela)
                        ctx.strokeStyle = '#ffeb3b'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(target.x, target.y); ctx.stroke();
                        audioSys.playSound('shoot'); // Som de zap
                    }
                }
            }

            // Power: POISON
            if (game.artifacts.poison) {
                this.poisonTimer++;
                if (this.poisonTimer > 20) {
                    this.poisonTimer = 0;
                    const radius = this.range * ARTIFACTS_DEF.poison.rangePct;
                    const dmg = ARTIFACTS_DEF.poison.baseDmg * game.artifacts.poison * 2;
                    entities.enemies.forEach(e => {
                        if (Math.hypot(e.x - this.x, e.y - this.y) < radius) {
                            e.takeDamage(dmg); entities.particles.push(new Particle(e.x, e.y, '#0f0'));
                        }
                    });
                }
            }

            // Shoot Logic
            let nearest = null; let minDist = Infinity;
            entities.enemies.forEach(e => {
                const d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < minDist && d <= this.range) { minDist = d; nearest = e; }
            });

            if (nearest) {
                this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                if (this.cooldown <= 0) {
                    entities.bullets.push(new Bullet(this.x, this.y, this.angle, this.damage));
                    this.cooldown = this.fireRate;
                    audioSys.playSound('shoot');
                    audioSys.playSound('shoot');
                }
            }
            if (this.cooldown > 0) this.cooldown--;
        }
        takeDamage(amount) {
            if (this.shieldActive) {
                this.shieldActive = false; this.shieldTimer = 0;
                for(let i=0; i<10; i++) entities.particles.push(new Particle(this.x, this.y, '#0072ff'));
                return;
            }
            this.hp -= amount; this.regenTimer = Date.now();
            ui.dmgOverlay.style.opacity = 0.5; setTimeout(() => ui.dmgOverlay.style.opacity = 0, 100);
            this.updateHpUI();
            audioSys.playSound('hit');

            if (this.hp <= 0) endGame();
        }

        updateHpUI() {
            const pct = (this.hp / this.maxHp) * 100;
            ui.hpBar.style.width = Math.max(0, pct) + '%';
            ui.hpBar.style.backgroundColor = pct < 30 ? '#f00' : '#0f0';
        }

        draw() {
            ctx.save(); ctx.translate(this.x, this.y); 
            if (game.artifacts.poison) {
                ctx.beginPath(); ctx.arc(0, 0, this.range * ARTIFACTS_DEF.poison.rangePct, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'; ctx.fill();
            }
            ctx.rotate(this.angle);
            ctx.fillStyle = '#222'; ctx.fillRect(-14, -14, 28, 28);
            ctx.fillStyle = this.color; ctx.fillRect(-12, -12, 24, 24);
            ctx.fillStyle = '#fff'; ctx.fillRect(5, -4, 20, 8);
            ctx.restore();
            if (this.shieldActive) {
                ctx.strokeStyle = '#0072ff'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(this.x, this.y, 35, 0, Math.PI*2); ctx.stroke();
            }
            ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth=1;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.range, 0, Math.PI*2); ctx.stroke();
        }
    }

    class Enemy {
        constructor(wave) {
            const key = game.spawnPool[Math.floor(Math.random() * game.spawnPool.length)];
            const def = ENEMIES_DEF[key];
            this.shape = def.shape; this.color = def.color;
            this.maxHp = 10 + (wave * 3); this.speed = 1.5; this.size = 20; this.goldChance = 0.2;
            
            // Balanceamento Apocal√≠ptico e Novos Tipos
            if (key === 'triangle') { this.speed = 3.5; this.maxHp *= 0.6; this.size=15; }
            if (key === 'circle') { this.speed = 0.7; this.maxHp *= 2.5; this.size=30; this.goldChance=0.8; } // Nerfado de 4x para 2.5x
            if (key === 'rhombus') { this.speed = 4; this.dashTimer = 0; } // Ladino
            if (key === 'hexagon') { this.speed = 1; this.healTimer = 0; this.color = '#00ff00'; } // Healer
            this.hp = this.maxHp; this.freezeTimer = 0; this.hitTimer = 0;

            const edge = Math.floor(Math.random()*4);
            if(edge===0){this.x=Math.random()*canvas.width; this.y=-40;}
            else if(edge===1){this.x=canvas.width+40; this.y=Math.random()*canvas.height;}
            else if(edge===2){this.x=Math.random()*canvas.width; this.y=canvas.height+40;}
            else{this.x=-40; this.y=Math.random()*canvas.height;}
        }

        update() {
            if (this.hitTimer > 0) this.hitTimer--;
            if (this.freezeTimer > 0) { this.freezeTimer--; return; }

            // L√≥gica Especial: Hex√°gono Cura
            if (this.shape === 'hexagon') {
                this.healTimer++;
                if (this.healTimer > 60) {
                    this.healTimer = 0;
                    entities.enemies.forEach(e => {
                        if (e !== this && Math.hypot(e.x-this.x, e.y-this.y) < 100) {
                            e.hp = Math.min(e.maxHp, e.hp + 10);
                            entities.particles.push(new Particle(e.x, e.y, '#00ff00'));
                        }
                    });
                }
            }

            // L√≥gica Especial: Losango Dash
            if (this.shape === 'rhombus') {
                // Ele para e corre
                if (Math.random() < 0.05) this.speed = 8; else this.speed = 0.5;
            }

            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;
        }

        takeDamage(amt) {
            this.hp -= amt; this.hitTimer = 5;
            if (this.hp <= 0) this.die();
        }

        die() {
            if (game.artifacts.vampire) {
                const healAmt = ARTIFACTS_DEF.vampire.heal + (game.artifacts.vampire * 2);
                player.hp = Math.min(player.maxHp, player.hp + healAmt); player.updateHpUI();
                entities.particles.push(new Particle(player.x, player.y, '#ff0000'));
            }
            game.score++; ui.score.innerText = game.score;
            for(let i=0; i<5; i++) entities.particles.push(new Particle(this.x, this.y, this.color));
            if (Math.random() < this.goldChance) entities.drops.push(new Drop(this.x, this.y, 'gold'));
            entities.drops.push(new Drop(this.x, this.y, 'xp'));
        }

        draw() {
            if (this.hitTimer > 0) ctx.fillStyle = '#ffffff';
            else ctx.fillStyle = this.freezeTimer > 0 ? '#00ffff' : this.color;
            if (this.shape === 'circle') { ctx.beginPath(); ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2); ctx.fill(); }
            else if (this.shape === 'triangle') { ctx.beginPath(); ctx.moveTo(this.x, this.y-this.size/2); ctx.lineTo(this.x+this.size/2, this.y+this.size/2); ctx.lineTo(this.x-this.size/2, this.y+this.size/2); ctx.fill(); }
            else { ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size); }
            if (this.shape === 'rhombus') {
                 ctx.beginPath(); ctx.moveTo(this.x, this.y-this.size/2); ctx.lineTo(this.x+this.size/2, this.y); ctx.lineTo(this.x, this.y+this.size/2); ctx.lineTo(this.x-this.size/2, this.y); ctx.fill();
             } else if (this.shape === 'hexagon') {
                 // Simplificado como c√≠rculo com borda
                 ctx.beginPath(); ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2); ctx.fill();
                 ctx.strokeStyle='#fff'; ctx.stroke();
             }

            if (this.hp < this.maxHp) {
                const pct = this.hp / this.maxHp;
                ctx.fillStyle = '#500'; ctx.fillRect(this.x-10, this.y-this.size-8, 20, 4);
                ctx.fillStyle = '#0f0'; ctx.fillRect(this.x-10, this.y-this.size-8, 20*pct, 4);
            }
        }
    }

    class Bullet {
        constructor(x,y,a,dmg) { 
            this.x=x; this.y=y; this.startX=x; this.startY=y; // Salva origem para Sniper
            this.vx=Math.cos(a)*12; this.vy=Math.sin(a)*12; 
            this.dmg=dmg; this.r=4; this.del=false;
            
            // Power: PIERCING
            this.pierce = 0;
            if (game.artifacts.piercing) this.pierce = ARTIFACTS_DEF.piercing.count + (game.artifacts.piercing - 1);
            
            this.hitList = []; // Lista de IDs de inimigos j√° acertados (para n√£o acertar o mesmo 2x no piercing)
        }
        update() { 
            this.x+=this.vx; this.y+=this.vy; 
            if(this.x<0||this.x>canvas.width||this.y<0||this.y>canvas.height) this.del=true; 
        }
        draw() { ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fillStyle='#fffa'; ctx.fill(); }
    }

    class Particle {
        constructor(x,y,c) { this.x=x; this.y=y; this.c=c; this.life=1; this.vx=(Math.random()-0.5)*5; this.vy=(Math.random()-0.5)*5; }
        update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; }
        draw() { ctx.globalAlpha=this.life; ctx.fillStyle=this.c; ctx.beginPath(); ctx.arc(this.x,this.y,Math.random()*4,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    }

    class Drop {
        constructor(x,y,t) { this.x=x; this.y=y; this.t=t; this.timer=30; this.del=false; this.vx=(Math.random()-0.5)*5; this.vy=(Math.random()-0.5)*5; }
        update() {
            this.x+=this.vx; this.y+=this.vy; this.vx*=0.9; this.vy*=0.9;
            if(this.timer>0) this.timer--;
            else {
                const a=Math.atan2(player.y-this.y, player.x-this.x); this.x+=Math.cos(a)*9; this.y+=Math.sin(a)*9;
                if(Math.hypot(player.x-this.x, player.y-this.y)<30) {
                    this.del=true;
                    if(this.t==='gold') { game.gold+=10; audioSys.playSound('coin'); ui.gold.innerText=game.gold; updateShopUI(); }
                    else { game.xp+=15; checkLevelUp(); }
                }
            }
        }
        draw() { 
            ctx.fillStyle = this.t==='gold'?'#ffd700':'#00c6ff';
            if(this.t==='gold') ctx.fillRect(this.x-4,this.y-4,8,8); else { ctx.beginPath(); ctx.arc(this.x,this.y,5,0,Math.PI*2); ctx.fill(); }
        }
    }

    // --- LOOP ---
    function loop(now) {
        animationId = requestAnimationFrame(loop);
        if (game.state !== 'PLAYING') return;

        if (now - game.lastTime >= 1000) {
            game.waveTimer--; ui.timer.innerText = game.waveTimer;
            if (game.waveTimer <= 0) nextWave();
            game.lastTime = now;
        }

        ctx.fillStyle = 'rgba(21, 21, 21, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);

        spawnTimer++;
        if (spawnTimer >= game.spawnRate) { entities.enemies.push(new Enemy(game.wave)); spawnTimer = 0; }

        player.update(); player.draw();

        entities.enemies.forEach((e, i) => {
            e.update(); e.draw();
            // Colis√£o Player
            if (Math.hypot(player.x-e.x, player.y-e.y) < player.size + e.size/2) {
                if (game.artifacts.midas) entities.drops.push(new Drop(e.x, e.y, 'gold'));
                player.takeDamage(15);
                e.die(); entities.enemies.splice(i, 1); return;
            }
            // Colis√£o Bala
            entities.bullets.forEach(b => {
                // Checa se j√° acertou esse inimigo (para piercing)
                if (!b.del && !b.hitList.includes(e) && Math.hypot(b.x-e.x, b.y-e.y) < e.size/2+b.r) {
                    
                    // Power: SNIPER (Dano por dist√¢ncia)
                    let finalDmg = b.dmg;
                    if (game.artifacts.sniper) {
                        const dist = Math.hypot(b.x - b.startX, b.y - b.startY);
                        const mult = 1 + (dist * (ARTIFACTS_DEF.sniper.mult * game.artifacts.sniper));
                        finalDmg *= mult;
                    }

                    e.takeDamage(finalDmg);
                    b.hitList.push(e); // Marca inimigo como atingido

                    // L√≥gica de PIERCING
                    if (b.pierce > 0) {
                        b.pierce--; // Continua vivo, mas perde 1 carga
                    } else {
                        b.del = true; // Morre
                    }

                    // Power: ECHO (Ricochete)
                    if (game.artifacts.echo && Math.random() < 0.5) { // 50% chance para n√£o lagar
                        const echoDmg = finalDmg * (ARTIFACTS_DEF.echo.dmgPct + (game.artifacts.echo * 0.1));
                        // Cria bala nova indo pro inimigo mais pr√≥ximo (exceto o atual)
                        const others = entities.enemies.filter(en => en !== e);
                        if (others.length > 0) {
                            const nearest = others.reduce((prev, curr) => Math.hypot(curr.x-b.x, curr.y-b.y) < Math.hypot(prev.x-b.x, prev.y-b.y) ? curr : prev);
                            const ang = Math.atan2(nearest.y - b.y, nearest.x - b.x);
                            entities.bullets.push(new Bullet(b.x, b.y, ang, echoDmg));
                        }
                    }

                    // Efeitos existentes (Freeze, Knockback, Explosive)...
                    if (game.artifacts.freeze) e.freezeTimer = ARTIFACTS_DEF.freeze.duration + (game.artifacts.freeze * 10);
                    if (game.artifacts.knockback) {
                        const force = ARTIFACTS_DEF.knockback.force + (game.artifacts.knockback * 3);
                        const a = Math.atan2(e.y-b.y, e.x-b.x); e.x+=Math.cos(a)*force; e.y+=Math.sin(a)*force;
                    }
                    if (game.artifacts.explosive) {
                        const range = ARTIFACTS_DEF.explosive.radius + (game.artifacts.explosive * 15);
                        const dmg = finalDmg * ARTIFACTS_DEF.explosive.dmgPct;
                        ctx.beginPath(); ctx.arc(b.x,b.y,range,0,Math.PI*2); ctx.fillStyle='rgba(255,170,0,0.3)'; ctx.fill();
                        audioSys.playSound('explosion');
                        entities.enemies.forEach(o => { if(o!==e && Math.hypot(o.x-b.x,o.y-b.y)<range) o.takeDamage(dmg); });
                    }
                }
            });
            if(e.hp<=0 && !e.markedForDeletion) entities.enemies.splice(i,1);
        });

        entities.bullets = entities.bullets.filter(b => { b.update(); b.draw(); return !b.del; });
        entities.drops = entities.drops.filter(d => { d.update(); d.draw(); return !d.del; });
        entities.particles = entities.particles.filter(p => { p.update(); p.draw(); return p.life>0; });
    }

    init();

</script>
</body>
</html>